{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport { useRef, useState, useCallback, useEffect } from 'react';\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core';\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix.js';\nimport { validateE164Number } from './helpers/isE164Number.js';\nimport { removePrefixFromFormattedPhoneNumber } from './helpers/inputValuePrefix.js';\n\n/**\r\n * Returns `[phoneDigits, setPhoneDigits]`.\r\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\r\n */\nexport default function usePhoneDigits(_ref) {\n  var _this = this;\n  var value = _ref.value,\n    onChange = _ref.onChange,\n    country = _ref.country,\n    defaultCountry = _ref.defaultCountry,\n    international = _ref.international,\n    withCountryCallingCode = _ref.withCountryCallingCode,\n    useNationalFormatForDefaultCountryValue = _ref.useNationalFormatForDefaultCountryValue,\n    metadata = _ref.metadata;\n  // Validate the use of `withCountryCallingCode` property.\n  if (typeof withCountryCallingCode === 'boolean' && !(country && international)) {\n    console.error('[react-phone-number-input] `withCountryCallingCode` property can only be used together with `country` and `international` properties');\n  }\n\n  // Validate the use of `country` and `defaultCountry` properties.\n  if (country && defaultCountry) {\n    console.error('[react-phone-number-input] When `country` property is passed, `defaultCountry` property has no effect and therefore shouldn\\'t be passed');\n  }\n\n  // Validate the use of `international` property.\n  if (typeof international === 'boolean' && !country) {\n    console.error('[react-phone-number-input] `international` property can only be used together with `country` property');\n  }\n  var inputFormat = getInputFormat({\n    international: international,\n    country: country,\n    defaultCountry: defaultCountry,\n    withCountryCallingCode: withCountryCallingCode\n  });\n  var countryMismatchDetected = useRef();\n  var onCountryMismatch = function onCountryMismatch(value, country, actualCountry) {\n    console.error(\"[react-phone-number-input] Expected phone number \".concat(value, \" to correspond to country \").concat(country, \" but \").concat(actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t', \".\"));\n    countryMismatchDetected.current = true;\n  };\n  var getInitialPhoneDigits = function getInitialPhoneDigits(options) {\n    // Validate that the initially-supplied `value` is in `E.164` format.\n    // Because sometimes people attempt to supply a `value` like \"+1 (879) 490-8676\".\n    // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/231#note_2016334796\n    if (value) {\n      validateE164Number(value);\n    }\n    return getPhoneDigitsForValue(value, country, defaultCountry, inputFormat, useNationalFormatForDefaultCountryValue, metadata, function () {\n      if (options && options.onCountryMismatch) {\n        options.onCountryMismatch();\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      onCountryMismatch.apply(_this, args);\n    });\n  };\n\n  // This is only used to detect `country` property change.\n  var _useState = useState(country),\n    _useState2 = _slicedToArray(_useState, 2),\n    prevCountry = _useState2[0],\n    setPrevCountry = _useState2[1];\n\n  // This is only used to detect `defaultCountry` property change.\n  var _useState3 = useState(defaultCountry),\n    _useState4 = _slicedToArray(_useState3, 2),\n    prevDefaultCountry = _useState4[0],\n    setPrevDefaultCountry = _useState4[1];\n\n  // `phoneDigits` is the a property that gets passed to the `<input/>` component as its \"value\":\n  // * `phoneDigits` is the `<input value/>` property.\n  // * `value` is the `<PhoneInput value/>` property.\n  var _useState5 = useState(getInitialPhoneDigits()),\n    _useState6 = _slicedToArray(_useState5, 2),\n    phoneDigits = _useState6[0],\n    setPhoneDigits = _useState6[1];\n\n  // This is only used to detect `value` property changes.\n  var _useState7 = useState(value),\n    _useState8 = _slicedToArray(_useState7, 2),\n    valueForPhoneDigits = _useState8[0],\n    setValueForPhoneDigits = _useState8[1];\n\n  // Rerender hack.\n  var _useState9 = useState(),\n    _useState10 = _slicedToArray(_useState9, 2),\n    rerenderTrigger = _useState10[0],\n    setRerenderTrigger = _useState10[1];\n  var rerender = useCallback(function () {\n    return setRerenderTrigger({});\n  }, [setRerenderTrigger]);\n  function getValueForPhoneDigits(phoneDigits) {\n    // If the user hasn't input any digits then `value` is `undefined`.\n    if (!phoneDigits) {\n      return;\n    }\n    if (inputFormat === 'NATIONAL_PART_OF_INTERNATIONAL') {\n      phoneDigits = \"+\".concat(getCountryCallingCode(country, metadata)).concat(phoneDigits);\n    }\n    // Return the E.164 phone number value.\n    //\n    // Even if no \"national (significant) number\" digits have been input,\n    // still return a non-`undefined` value.\n    // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\n    //\n    // For example, if the user has selected country `US` and entered `\"1\"`\n    // then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\n    // digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\n    // because otherwise the app would think that the input is empty and mark it as such\n    // while in reality it isn't empty, which might be thought of as a \"bug\", or just\n    // a \"weird\" behavior.\n    //\n    // The only case when there's any input and `getNumberValue()` still returns `undefined`\n    // is when that input is `\"+\"`.\n    //\n    var asYouType = new AsYouType(country || defaultCountry, metadata);\n    asYouType.input(phoneDigits);\n    return asYouType.getNumberValue();\n  }\n\n  // If `value` property has been changed externally\n  // then re-initialize the component.\n  useEffect(function () {\n    if (value !== valueForPhoneDigits) {\n      setValueForPhoneDigits(value);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [value]);\n\n  // If the `country` has been changed then re-initialize the component.\n  useEffect(function () {\n    if (country !== prevCountry) {\n      setPrevCountry(country);\n      var _countryMismatchDetected;\n      var _phoneDigits = getInitialPhoneDigits({\n        onCountryMismatch: function onCountryMismatch() {\n          _countryMismatchDetected = true;\n        }\n      });\n      setPhoneDigits(_phoneDigits);\n      if (_countryMismatchDetected) {\n        setValueForPhoneDigits(getValueForPhoneDigits(_phoneDigits));\n      }\n    }\n  }, [country]);\n\n  // If the `defaultCountry` has been changed then re-initialize the component.\n  useEffect(function () {\n    if (defaultCountry !== prevDefaultCountry) {\n      setPrevDefaultCountry(defaultCountry);\n      setPhoneDigits(getInitialPhoneDigits());\n    }\n  }, [defaultCountry]);\n\n  // Update the `value` after `valueForPhoneDigits` has been updated.\n  useEffect(function () {\n    if (valueForPhoneDigits !== value) {\n      onChange(valueForPhoneDigits);\n    }\n  }, [valueForPhoneDigits]);\n  var onSetPhoneDigits = useCallback(function (phoneDigits) {\n    var value;\n    if (country) {\n      if (inputFormat === 'INTERNATIONAL') {\n        // The `<input/>` value must start with the country calling code.\n        var prefix = getInternationalPhoneNumberPrefix(country, metadata);\n        if (phoneDigits.indexOf(prefix) !== 0) {\n          // If a user tabs into a phone number input field\n          // that is in `withCountryCallingCode` mode,\n          // and then starts inputting local phone number digits,\n          // the first digit would get \"swallowed\" if the fix below wasn't implemented.\n          // https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\n          if (phoneDigits && phoneDigits[0] !== '+') {\n            phoneDigits = prefix + phoneDigits;\n          } else {\n            // // Reset phone digits if they don't start with the correct prefix.\n            // // Undo the `<input/>` value change if it doesn't.\n            if (countryMismatchDetected.current) {\n              // In case of a `country`/`value` mismatch,\n              // if it performed an \"undo\" here, then\n              // it wouldn't let a user edit their phone number at all,\n              // so this special case at least allows phone number editing\n              // when `value` already doesn't match the `country`.\n            } else {\n              // If it simply did `phoneDigits = prefix` here,\n              // then it could have no effect when erasing phone number\n              // via Backspace, because `phoneDigits` in `state` wouldn't change\n              // as a result, because it was `prefix` and it became `prefix`,\n              // so the component wouldn't rerender, and the user would be able\n              // to erase the country calling code part, and that part is\n              // assumed to be non-eraseable. That's why the component is\n              // forcefully rerendered here.\n              setPhoneDigits(prefix);\n              setValueForPhoneDigits(undefined);\n              // Force a re-render of the `<input/>` with previous `phoneDigits` value.\n              return rerender();\n            }\n          }\n        }\n      } else {\n        // Entering phone number either in \"NATIONAL\" or in \"NATIONAL_PART_OF_INTERNATIONAL\" format.\n        // Therefore, `+` is not allowed.\n        if (phoneDigits && phoneDigits[0] === '+') {\n          // Remove the `+`.\n          phoneDigits = phoneDigits.slice(1);\n        }\n      }\n    } else if (!defaultCountry) {\n      // Force a `+` in the beginning of a `value`\n      // when no `country` and `defaultCountry` have been specified.\n      if (phoneDigits && phoneDigits[0] !== '+') {\n        // Prepend a `+`.\n        phoneDigits = '+' + phoneDigits;\n      }\n    }\n    // Convert `phoneDigits` to `value`.\n    if (phoneDigits) {\n      value = getValueForPhoneDigits(phoneDigits);\n    }\n    setPhoneDigits(phoneDigits);\n    setValueForPhoneDigits(value);\n  }, [country, inputFormat, defaultCountry, metadata, setPhoneDigits, setValueForPhoneDigits, rerender, countryMismatchDetected]);\n  return {\n    phoneDigits: phoneDigits,\n    setPhoneDigits: onSetPhoneDigits,\n    inputFormat: inputFormat\n  };\n}\n\n/**\r\n * Returns phone number input field value for a E.164 phone number `value`.\r\n * @param  {string} [value]\r\n * @param  {string} [country]\r\n * @param  {string} [inputFormat]\r\n * @param  {string} [defaultCountry]\r\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\nfunction getPhoneDigitsForValue(value, country, defaultCountry, inputFormat, useNationalFormatForDefaultCountryValue, metadata, onCountryMismatch) {\n  if (country && inputFormat === 'INTERNATIONAL') {\n    var prefix = getInternationalPhoneNumberPrefix(country, metadata);\n    if (value) {\n      if (value.indexOf(prefix) !== 0) {\n        onCountryMismatch(value, country);\n      }\n      return value;\n    }\n    return prefix;\n  }\n  if (!value) {\n    return '';\n  }\n  if (!country && !defaultCountry) {\n    return value;\n  }\n  var asYouType = new AsYouType(undefined, metadata);\n  asYouType.input(value);\n  var phoneNumber = asYouType.getNumber();\n  if (phoneNumber) {\n    if (country) {\n      // Check for `country` property mismatch for the actual `value`.\n      if (phoneNumber.country && phoneNumber.country !== country) {\n        onCountryMismatch(value, country, phoneNumber.country);\n      } else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\n        onCountryMismatch(value, country);\n      }\n      switch (inputFormat) {\n        case 'NATIONAL':\n          return parseDigits(phoneNumber.formatNational());\n        case 'NATIONAL_PART_OF_INTERNATIONAL':\n          return parseDigits(removePrefixFromFormattedPhoneNumber(phoneNumber.formatInternational(), getInternationalPhoneNumberPrefix(country, metadata)));\n        case 'INTERNATIONAL':\n          throw new Error('`inputFormat: \"INTERNATIONAL\"` case should\\'ve already been handled earlier in the code');\n        case 'INTERNATIONAL_OR_NATIONAL':\n          throw new Error('`inputFormat: \"INTERNATIONAL_OR_NATIONAL\"` is not possible when `country` is fixed');\n        default:\n          throw new Error(\"Unknown `inputFormat`: \".concat(inputFormat));\n      }\n    } else {\n      // `phoneNumber.countryCallingCode` is compared here  instead of\n      // `phoneNumber.country`, because, for example, a person could have\n      // previously input a phone number (in \"national\" format) that isn't\n      // 100% valid for the `defaultCountry`, and if `phoneNumber.country`\n      // was compared, then it wouldn't match, and such phone number\n      // wouldn't be formatted as a \"national\" one, and instead would be\n      // formatted as an \"international\" one, confusing the user.\n      // Comparing `phoneNumber.countryCallingCode` works around such issues.\n      //\n      // Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\n      // The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\n      // The user then clicks \"Save\", the page is refreshed, and the user sees\n      // that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\n      // the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\n      // was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\n      // is not a valid national number for US, and `phoneNumber.country` is compared\n      // instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\n      // comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\n      // is no longer the case.\n      //\n      if (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\n        return parseDigits(phoneNumber.formatNational());\n      }\n      return value;\n    }\n  } else {\n    return '';\n  }\n}\nfunction getInputFormat(_ref2) {\n  var international = _ref2.international,\n    country = _ref2.country,\n    defaultCountry = _ref2.defaultCountry,\n    withCountryCallingCode = _ref2.withCountryCallingCode;\n  return country ? international ? withCountryCallingCode ? 'INTERNATIONAL' : 'NATIONAL_PART_OF_INTERNATIONAL' : 'NATIONAL' : defaultCountry ? 'INTERNATIONAL_OR_NATIONAL' : 'INTERNATIONAL';\n}","map":{"version":3,"names":["useRef","useState","useCallback","useEffect","AsYouType","getCountryCallingCode","parseDigits","getInternationalPhoneNumberPrefix","validateE164Number","removePrefixFromFormattedPhoneNumber","usePhoneDigits","_ref","_this","value","onChange","country","defaultCountry","international","withCountryCallingCode","useNationalFormatForDefaultCountryValue","metadata","console","error","inputFormat","getInputFormat","countryMismatchDetected","onCountryMismatch","actualCountry","concat","current","getInitialPhoneDigits","options","getPhoneDigitsForValue","_len","arguments","length","args","Array","_key","apply","_useState","_useState2","_slicedToArray","prevCountry","setPrevCountry","_useState3","_useState4","prevDefaultCountry","setPrevDefaultCountry","_useState5","_useState6","phoneDigits","setPhoneDigits","_useState7","_useState8","valueForPhoneDigits","setValueForPhoneDigits","_useState9","_useState10","rerenderTrigger","setRerenderTrigger","rerender","getValueForPhoneDigits","asYouType","input","getNumberValue","_countryMismatchDetected","_phoneDigits","onSetPhoneDigits","prefix","indexOf","undefined","slice","phoneNumber","getNumber","countryCallingCode","formatNational","formatInternational","Error","_ref2"],"sources":["D:\\medicine\\frontend\\node_modules\\react-phone-number-input\\source\\usePhoneDigits.js"],"sourcesContent":["import { useRef, useState, useCallback, useEffect } from 'react'\r\nimport { AsYouType, getCountryCallingCode, parseDigits } from 'libphonenumber-js/core'\r\n\r\nimport getInternationalPhoneNumberPrefix from './helpers/getInternationalPhoneNumberPrefix.js'\r\nimport { validateE164Number } from './helpers/isE164Number.js'\r\nimport { removePrefixFromFormattedPhoneNumber } from './helpers/inputValuePrefix.js'\r\n\r\n/**\r\n * Returns `[phoneDigits, setPhoneDigits]`.\r\n * \"Phone digits\" includes not only \"digits\" but also a `+` sign.\r\n */\r\nexport default function usePhoneDigits({\r\n\tvalue,\r\n\tonChange,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tinternational,\r\n\twithCountryCallingCode,\r\n\tuseNationalFormatForDefaultCountryValue,\r\n\tmetadata\r\n}) {\r\n\t// Validate the use of `withCountryCallingCode` property.\r\n\tif (typeof withCountryCallingCode === 'boolean' && !(country && international)) {\r\n\t\tconsole.error('[react-phone-number-input] `withCountryCallingCode` property can only be used together with `country` and `international` properties')\r\n\t}\r\n\r\n\t// Validate the use of `country` and `defaultCountry` properties.\r\n\tif (country && defaultCountry) {\r\n\t\tconsole.error('[react-phone-number-input] When `country` property is passed, `defaultCountry` property has no effect and therefore shouldn\\'t be passed')\r\n\t}\r\n\r\n\t// Validate the use of `international` property.\r\n\tif (typeof international === 'boolean' && !country) {\r\n\t\tconsole.error('[react-phone-number-input] `international` property can only be used together with `country` property')\r\n\t}\r\n\r\n\tconst inputFormat = getInputFormat({\r\n\t\tinternational,\r\n\t\tcountry,\r\n\t\tdefaultCountry,\r\n\t\twithCountryCallingCode\r\n\t})\r\n\r\n\tconst countryMismatchDetected = useRef()\r\n\tconst onCountryMismatch = (value, country, actualCountry) => {\r\n\t\tconsole.error(`[react-phone-number-input] Expected phone number ${value} to correspond to country ${country} but ${actualCountry ? 'in reality it corresponds to country ' + actualCountry : 'it doesn\\'t'}.`)\r\n\t\tcountryMismatchDetected.current = true\r\n\t}\r\n\r\n\tconst getInitialPhoneDigits = (options) => {\r\n\t\t// Validate that the initially-supplied `value` is in `E.164` format.\r\n\t\t// Because sometimes people attempt to supply a `value` like \"+1 (879) 490-8676\".\r\n\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/231#note_2016334796\r\n\t\tif (value) {\r\n\t\t\tvalidateE164Number(value)\r\n\t\t}\r\n\r\n\t\treturn getPhoneDigitsForValue(\r\n\t\t\tvalue,\r\n\t\t\tcountry,\r\n\t\t\tdefaultCountry,\r\n\t\t\tinputFormat,\r\n\t\t\tuseNationalFormatForDefaultCountryValue,\r\n\t\t\tmetadata,\r\n\t\t\t(...args) => {\r\n\t\t\t\tif (options && options.onCountryMismatch) {\r\n\t\t\t\t\toptions.onCountryMismatch()\r\n\t\t\t\t}\r\n\t\t\t\tonCountryMismatch.apply(this, args)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\r\n\t// This is only used to detect `country` property change.\r\n\tconst [prevCountry, setPrevCountry] = useState(country)\r\n\r\n\t// This is only used to detect `defaultCountry` property change.\r\n\tconst [prevDefaultCountry, setPrevDefaultCountry] = useState(defaultCountry)\r\n\r\n\t// `phoneDigits` is the a property that gets passed to the `<input/>` component as its \"value\":\r\n\t// * `phoneDigits` is the `<input value/>` property.\r\n\t// * `value` is the `<PhoneInput value/>` property.\r\n\tconst [phoneDigits, setPhoneDigits] = useState(getInitialPhoneDigits())\r\n\r\n\t// This is only used to detect `value` property changes.\r\n\tconst [valueForPhoneDigits, setValueForPhoneDigits] = useState(value)\r\n\r\n\t// Rerender hack.\r\n\tconst [rerenderTrigger, setRerenderTrigger] = useState()\r\n\tconst rerender = useCallback(() => setRerenderTrigger({}), [setRerenderTrigger])\r\n\r\n\tfunction getValueForPhoneDigits(phoneDigits) {\r\n\t\t// If the user hasn't input any digits then `value` is `undefined`.\r\n\t\tif (!phoneDigits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (inputFormat === 'NATIONAL_PART_OF_INTERNATIONAL') {\r\n\t\t\tphoneDigits = `+${getCountryCallingCode(country, metadata)}${phoneDigits}`\r\n\t\t}\r\n\t\t// Return the E.164 phone number value.\r\n\t\t//\r\n\t\t// Even if no \"national (significant) number\" digits have been input,\r\n\t\t// still return a non-`undefined` value.\r\n\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/113\r\n\t\t//\r\n\t\t// For example, if the user has selected country `US` and entered `\"1\"`\r\n\t\t// then that `\"1\"` is just a \"national prefix\" and no \"national (significant) number\"\r\n\t\t// digits have been input yet. Still, return `\"+1\"` as `value` in such cases,\r\n\t\t// because otherwise the app would think that the input is empty and mark it as such\r\n\t\t// while in reality it isn't empty, which might be thought of as a \"bug\", or just\r\n\t\t// a \"weird\" behavior.\r\n\t\t//\r\n\t\t// The only case when there's any input and `getNumberValue()` still returns `undefined`\r\n\t\t// is when that input is `\"+\"`.\r\n\t\t//\r\n\t\tconst asYouType = new AsYouType(country || defaultCountry, metadata)\r\n\t\tasYouType.input(phoneDigits)\r\n\t\treturn asYouType.getNumberValue()\r\n\t}\r\n\r\n\t// If `value` property has been changed externally\r\n\t// then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (value !== valueForPhoneDigits) {\r\n\t\t\tsetValueForPhoneDigits(value)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [value])\r\n\r\n\t// If the `country` has been changed then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (country !== prevCountry) {\r\n\t\t\tsetPrevCountry(country)\r\n\t\t\tlet countryMismatchDetected\r\n\t\t\tconst phoneDigits = getInitialPhoneDigits({\r\n\t\t\t\tonCountryMismatch() {\r\n\t\t\t\t\tcountryMismatchDetected = true\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tsetPhoneDigits(phoneDigits)\r\n\t\t\tif (countryMismatchDetected) {\r\n\t\t\t\tsetValueForPhoneDigits(getValueForPhoneDigits(phoneDigits))\r\n\t\t\t}\r\n\t\t}\r\n\t}, [country])\r\n\r\n\t// If the `defaultCountry` has been changed then re-initialize the component.\r\n\tuseEffect(() => {\r\n\t\tif (defaultCountry !== prevDefaultCountry) {\r\n\t\t\tsetPrevDefaultCountry(defaultCountry)\r\n\t\t\tsetPhoneDigits(getInitialPhoneDigits())\r\n\t\t}\r\n\t}, [defaultCountry])\r\n\r\n\t// Update the `value` after `valueForPhoneDigits` has been updated.\r\n\tuseEffect(() => {\r\n\t\tif (valueForPhoneDigits !== value) {\r\n\t\t\tonChange(valueForPhoneDigits)\r\n\t\t}\r\n\t}, [valueForPhoneDigits])\r\n\r\n\tconst onSetPhoneDigits = useCallback((phoneDigits) => {\r\n\t\tlet value\r\n\t\tif (country) {\r\n\t\t\tif (inputFormat === 'INTERNATIONAL') {\r\n\t\t\t\t// The `<input/>` value must start with the country calling code.\r\n\t\t\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\t\t\tif (phoneDigits.indexOf(prefix) !== 0) {\r\n\t\t\t\t\t// If a user tabs into a phone number input field\r\n\t\t\t\t\t// that is in `withCountryCallingCode` mode,\r\n\t\t\t\t\t// and then starts inputting local phone number digits,\r\n\t\t\t\t\t// the first digit would get \"swallowed\" if the fix below wasn't implemented.\r\n\t\t\t\t\t// https://gitlab.com/catamphetamine/react-phone-number-input/-/issues/43\r\n\t\t\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\t\t\tphoneDigits = prefix + phoneDigits\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// // Reset phone digits if they don't start with the correct prefix.\r\n\t\t\t\t\t\t// // Undo the `<input/>` value change if it doesn't.\r\n\t\t\t\t\t\tif (countryMismatchDetected.current) {\r\n\t\t\t\t\t\t\t// In case of a `country`/`value` mismatch,\r\n\t\t\t\t\t\t\t// if it performed an \"undo\" here, then\r\n\t\t\t\t\t\t\t// it wouldn't let a user edit their phone number at all,\r\n\t\t\t\t\t\t\t// so this special case at least allows phone number editing\r\n\t\t\t\t\t\t\t// when `value` already doesn't match the `country`.\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// If it simply did `phoneDigits = prefix` here,\r\n\t\t\t\t\t\t\t// then it could have no effect when erasing phone number\r\n\t\t\t\t\t\t\t// via Backspace, because `phoneDigits` in `state` wouldn't change\r\n\t\t\t\t\t\t\t// as a result, because it was `prefix` and it became `prefix`,\r\n\t\t\t\t\t\t\t// so the component wouldn't rerender, and the user would be able\r\n\t\t\t\t\t\t\t// to erase the country calling code part, and that part is\r\n\t\t\t\t\t\t\t// assumed to be non-eraseable. That's why the component is\r\n\t\t\t\t\t\t\t// forcefully rerendered here.\r\n\t\t\t\t\t\t\tsetPhoneDigits(prefix)\r\n\t\t\t\t\t\t\tsetValueForPhoneDigits(undefined)\r\n\t\t\t\t\t\t\t// Force a re-render of the `<input/>` with previous `phoneDigits` value.\r\n\t\t\t\t\t\t\treturn rerender()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Entering phone number either in \"NATIONAL\" or in \"NATIONAL_PART_OF_INTERNATIONAL\" format.\r\n\t\t\t\t// Therefore, `+` is not allowed.\r\n\t\t\t\tif (phoneDigits && phoneDigits[0] === '+') {\r\n\t\t\t\t\t// Remove the `+`.\r\n\t\t\t\t\tphoneDigits = phoneDigits.slice(1)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (!defaultCountry) {\r\n\t\t\t// Force a `+` in the beginning of a `value`\r\n\t\t\t// when no `country` and `defaultCountry` have been specified.\r\n\t\t\tif (phoneDigits && phoneDigits[0] !== '+') {\r\n\t\t\t\t// Prepend a `+`.\r\n\t\t\t\tphoneDigits = '+' + phoneDigits\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Convert `phoneDigits` to `value`.\r\n\t\tif (phoneDigits) {\r\n\t\t\tvalue = getValueForPhoneDigits(phoneDigits)\r\n\t\t}\r\n\t\tsetPhoneDigits(phoneDigits)\r\n\t\tsetValueForPhoneDigits(value)\r\n\t}, [\r\n\t\tcountry,\r\n\t\tinputFormat,\r\n\t\tdefaultCountry,\r\n\t\tmetadata,\r\n\t\tsetPhoneDigits,\r\n\t\tsetValueForPhoneDigits,\r\n\t\trerender,\r\n\t\tcountryMismatchDetected\r\n\t])\r\n\r\n\treturn {\r\n\t\tphoneDigits,\r\n\t\tsetPhoneDigits: onSetPhoneDigits,\r\n\t\tinputFormat\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns phone number input field value for a E.164 phone number `value`.\r\n * @param  {string} [value]\r\n * @param  {string} [country]\r\n * @param  {string} [inputFormat]\r\n * @param  {string} [defaultCountry]\r\n * @param  {boolean} [useNationalFormatForDefaultCountryValue]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nfunction getPhoneDigitsForValue(\r\n\tvalue,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\tinputFormat,\r\n\tuseNationalFormatForDefaultCountryValue,\r\n\tmetadata,\r\n\tonCountryMismatch\r\n) {\r\n\tif (country && inputFormat === 'INTERNATIONAL') {\r\n\t\tconst prefix = getInternationalPhoneNumberPrefix(country, metadata)\r\n\t\tif (value) {\r\n\t\t\tif (value.indexOf(prefix) !== 0) {\r\n\t\t\t\tonCountryMismatch(value, country)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\treturn prefix\r\n\t}\r\n\r\n\tif (!value) {\r\n\t\treturn ''\r\n\t}\r\n\r\n\tif (!country && !defaultCountry) {\r\n\t\treturn value\r\n\t}\r\n\r\n\tconst asYouType = new AsYouType(undefined, metadata)\r\n\tasYouType.input(value)\r\n\tconst phoneNumber = asYouType.getNumber()\r\n\r\n\tif (phoneNumber) {\r\n\t\tif (country) {\r\n\t\t\t// Check for `country` property mismatch for the actual `value`.\r\n\t\t\tif (phoneNumber.country && phoneNumber.country !== country) {\r\n\t\t\t\tonCountryMismatch(value, country, phoneNumber.country)\r\n\t\t\t} else if (phoneNumber.countryCallingCode !== getCountryCallingCode(country, metadata)) {\r\n\t\t\t\tonCountryMismatch(value, country)\r\n\t\t\t}\r\n\t\t\tswitch (inputFormat) {\r\n\t\t\t\tcase 'NATIONAL':\r\n\t\t\t\t\treturn parseDigits(phoneNumber.formatNational())\r\n\t\t\t\tcase 'NATIONAL_PART_OF_INTERNATIONAL':\r\n\t\t\t\t\treturn parseDigits(\r\n\t\t\t\t\t\tremovePrefixFromFormattedPhoneNumber(\r\n\t\t\t\t\t\t\tphoneNumber.formatInternational(),\r\n\t\t\t\t\t\t\tgetInternationalPhoneNumberPrefix(country, metadata)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\tcase 'INTERNATIONAL':\r\n\t\t\t\t\tthrow new Error('`inputFormat: \"INTERNATIONAL\"` case should\\'ve already been handled earlier in the code')\r\n\t\t\t\tcase 'INTERNATIONAL_OR_NATIONAL':\r\n\t\t\t\t\tthrow new Error('`inputFormat: \"INTERNATIONAL_OR_NATIONAL\"` is not possible when `country` is fixed')\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(`Unknown \\`inputFormat\\`: ${inputFormat}`)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// `phoneNumber.countryCallingCode` is compared here  instead of\r\n\t\t\t// `phoneNumber.country`, because, for example, a person could have\r\n\t\t\t// previously input a phone number (in \"national\" format) that isn't\r\n\t\t\t// 100% valid for the `defaultCountry`, and if `phoneNumber.country`\r\n\t\t\t// was compared, then it wouldn't match, and such phone number\r\n\t\t\t// wouldn't be formatted as a \"national\" one, and instead would be\r\n\t\t\t// formatted as an \"international\" one, confusing the user.\r\n\t\t\t// Comparing `phoneNumber.countryCallingCode` works around such issues.\r\n\t\t\t//\r\n\t\t\t// Example: `defaultCountry=\"US\"` and the `<input/>` is empty.\r\n\t\t\t// The user inputs: \"222 333 4444\", which gets formatted to \"(222) 333-4444\".\r\n\t\t\t// The user then clicks \"Save\", the page is refreshed, and the user sees\r\n\t\t\t// that the `<input/>` value is now \"+1 222 333 4444\" which confuses the user:\r\n\t\t\t// the user expected the `<input/>` value to be \"(222) 333-4444\", same as it\r\n\t\t\t// was when they've just typed it in. The cause of the issue is that \"222 333 4444\"\r\n\t\t\t// is not a valid national number for US, and `phoneNumber.country` is compared\r\n\t\t\t// instead of `phoneNumber.countryCallingCode`. After the `phoneNumber.country`\r\n\t\t\t// comparison is replaced with `phoneNumber.countryCallingCode` one, the issue\r\n\t\t\t// is no longer the case.\r\n\t\t\t//\r\n\t\t\tif (phoneNumber.countryCallingCode && phoneNumber.countryCallingCode === getCountryCallingCode(defaultCountry, metadata) && useNationalFormatForDefaultCountryValue) {\r\n\t\t\t\treturn parseDigits(phoneNumber.formatNational())\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t} else {\r\n\t\treturn ''\r\n\t}\r\n}\r\n\r\nfunction getInputFormat({\r\n\tinternational,\r\n\tcountry,\r\n\tdefaultCountry,\r\n\twithCountryCallingCode\r\n}) {\r\n\treturn country ? (\r\n\t\tinternational ? (\r\n\t\t\twithCountryCallingCode ? 'INTERNATIONAL' : 'NATIONAL_PART_OF_INTERNATIONAL'\r\n\t\t) : 'NATIONAL'\r\n\t) : (\r\n\t\tdefaultCountry ? 'INTERNATIONAL_OR_NATIONAL' : 'INTERNATIONAL'\r\n\t)\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}